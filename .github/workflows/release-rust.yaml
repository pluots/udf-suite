---
name: "Rust Build & Release"

# This configuration largely comes from ripgrep

on:
  push:
    tags:
    - 'v*'
# on:
#   pull_request:

jobs:
  build_release:
    name: "Build ${{ matrix.build }} binaries (cargo build)"
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - build: linux
            os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            # extension: ''
            # Unsuccessful compilation; try on local
          # - build: linux-arm
          #   os: ubuntu-latest
          #   target: arm-unknown-linux-gnueabihf
          #   extension: ''
          # - build: macos
          #   os: macos-latest
          #   target: x86_64-apple-darwin
          #   extension: ''
          - build: windows-msvc
            os: windows-latest
            target: x86_64-pc-windows-msvc
            # extension: .exe
    env:
      CARGO: cargo
      TARGET_DIR: ./target
      TARGET_FLAGS: ""

    steps:
        # Retreive git files
      - uses: actions/checkout@v2
        # Set cache configuration
      - uses: actions/cache@v3
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
        # Install cargo
      - uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable
          override: true
          target: ${{ matrix.target }}
        # Debugging aid
      - name: Show commands
        run: |
          echo pwd:
          pwd
          echo ls:
          ls
          echo "cargo command is: ${{ env.CARGO }}"
          echo "target flag is: ${{ env.TARGET_FLAGS }}"
          echo "target dir is: ${{ env.TARGET_DIR }}"
      - name: Install libmysql (windows)
        # Setup vcpkg & install libmysql
        if: matrix.build == 'windows-msvc'
        run: |
          git clone https://github.com/Microsoft/vcpkg --depth 1 c:\projects\vcpkg
          c:\projects\vcpkg\bootstrap-vcpkg.bat
          set VCPKG_ROOT=c:\projects\vcpkg
          echo yes > %VCPKG_ROOT%\Downloads\AlwaysAllowDownloads
          %VCPKG_ROOT%\vcpkg.exe install libmysql
          # git clone https://github.com/Microsoft/vcpkg
          # .\vcpkg\bootstrap-vcpkg.bat
          # set VCPKG_ROOT=.\vcpkg
          # echo yes > %VCPKG_ROOT%\Downloads\AlwaysAllowDownloads
          # %VCPKG_ROOT%\vcpkg.exe install libmysql

      # install cmake
      # - uses: lukka/get-cmake@latest
      #   if: matrix.build == 'windows-msvc'
      # - name: Restore artifacts / setup vcpkg
      #   if: matrix.build == 'windows-msvc'
      #   uses: lukka/run-vcpkg@v10
      # - name: Run CMake consuming CMakePreset.json and vcpkg.json
      #   if: matrix.build == 'windows-msvc'
      #   uses: lukka/run-cmake@v10
      #   with:
      #     configurePreset: 'ninja-multi-vcpkg'
      #     buildPreset: 'ninja-multi-vcpkg'
      # - name: Install libmysql (windows)
      #   # Setup vcpkg & install libmysql
      #   if: matrix.build == 'windows-msvc'
      #   run: |
      #     vcpkg install libmysql


        # Perform build
      - uses: actions-rs/cargo@v1
        with:
          command: build
          args: --release --verbose --target ${{ matrix.target }}
      - name: Show output
        run: |
          ls target
          ls "target/${{ matrix.target }}"
          ls "target/${{ matrix.target }}/release"
      - name: Strip release binary (linux and macos)
        if: matrix.build == 'linux' || matrix.build == 'macos'
        # Remove debug symbols
        # These will exit 1 if the symbols aren't found, so we need to true-guard
        run: |
          strip "target/${{ matrix.target }}/release/"*.so || true
          strip "target/${{ matrix.target }}/release/"*.dylib || true
        # Create .zip or .tar.gz file
      - name: Build archive
        shell: bash
        run: |
          echo '\nWorking directory:' && pwd
          echo '\nls:' && ls

          # outdir="$(ci/cargo-out-dir "${{ env.TARGET_DIR }}")"
          # outdir=target/release/${{ steps.get_repository_name.outputs.REPOSITORY_NAME }}${{ matrix.extension }}
          # cargo_outdir="$(find "${{ env.TARGET_DIR }}" -name udfsuite-stamp -print0 | xargs -0 ls -t | head -n1 | xargs dirname)"
          ref_name=${GITHUB_REF##*/}

          # Remove leading 'v' for use where needed
          ref_name_stripped=$(echo $ref_name | perl -0pe 's/^v//')
          echo "\nRef name: \"$ref_name\""
          echo "\nRef name stripped: \"$ref_name_stripped\""

          staging="udfsuite-$ref_name-${{ matrix.target }}"

          # Remove the "unreleased" section from our changelog
          perl -0777 -i -pe "s/\n*(<\!-- next-header -->.*## \[Unreleased\].*?\n)(?=\n*^## )//gms" CHANGELOG.md

          cp {README.md,LICENSE,CHANGELOG.md} "$staging/"

          # Select the release notes from our latest version only
          perl -0777 -ne "print /(## \[$ref_name_stripped\].*?\n)(?=\n*^## )/gms" CHANGELOG.md > RNOTES.md
          # Select the diff URL for this version only
          perl -0777 -ne "print /\[$ref_name_stripped\]:.*?\n/gms" CHANGELOG.md >> RNOTES.md
          echo "\nRelease notes:" && cat RNOTES.md

          if [ "${{ matrix.os }}" = "windows-latest" ]; then
            cp "target/${{ matrix.target }}/release/*.dll" "$staging/"
            7z a "$staging.zip" "$staging"
            echo "ASSET=$staging.zip" >> $GITHUB_ENV
          else
            cp "target/${{ matrix.target }}/release/"*.so "$staging/" || true
            cp "target/${{ matrix.target }}/release/"*.dylib "$staging/" || true
            tar czf "$staging.tar.gz" "$staging"
            echo "ASSET=$staging.tar.gz" >> $GITHUB_ENV
          fi
        # Upload to github
      - name: Release
        uses: softprops/action-gh-release@v1
        if: startsWith(github.ref, 'refs/tags/')
        env:
          GITHUB_REPOSITORY: pluots/udf-suite
        with:
          body_path: RNOTES.md
          # note you'll typically need to create a personal access token
          # with permissions to create releases in the other repo
          token: ${{ secrets.GITHUB_TOKEN }}
          files: |
            ${{ env.ASSET }}
